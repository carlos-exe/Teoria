# -*- coding: utf-8 -*-
"""Taller3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LXcM2-U8qy7s36AONpKG9n5GEq34nrjj

# **Taller Teorico-Practico 3 Señales y Sistemas**

---



**2.Modelado y simulación de sistemas en el tiempo**

RESPUESTA AL IMPULSO
"""

from __future__ import print_function
import sympy as sym
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets
sym.init_printing()

t = sym.symbols('t', real=True)
x = sym.Function('x')(t)
y = sym.Function('y')(t)
ode = sym.Eq(y + y.diff(t) , x)
h = sym.Function('h')(t)
solution2 = sym.dsolve(ode.subs(x, sym.DiracDelta(t)).subs(y, h))
integration_constants = sym.solve( (solution2.rhs.limit(t, 0, '-'), solution2.rhs.diff(t).limit(t, 0, '-')), 'C1' )
h = solution2.subs(integration_constants)
solution = sym.dsolve(ode.subs(x, sym.exp(-2*t)*sym.Heaviside(t)))
integration_constants = sym.solve( (solution.rhs.limit(t, 0, '-'), solution.rhs.diff(t).limit(t, 0, '-')), 'C1' )
y1 = solution.subs(integration_constants)
tau = sym.symbols('tau', real=True)
y2 = sym.integrate(sym.exp(-2*tau) * h.rhs.subs(sym.Heaviside(t), 1).subs(t, t-tau), (tau, 0, t))
sym.plot((y1.rhs - y2), (t,0,10), ylabel=r'$y(t)$');

"""# **AUTOFUNCIONES**"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import sympy as sym
sym.init_printing()

t, s, a0, a1, a2 = sym.symbols('t s a:3')
x = sym.exp(s * t)
y = sym.Function('y')(t)

ode = sym.Eq(a0*y + a1*y.diff(t) + a2*y.diff(t,2), x)
solution = sym.dsolve(ode)
solution.subs({'C1': 0, 'C2' : 0})

x = sym.exp(s * t)
l = sym.symbols(u"λ")
y = l*sym.exp(s * t)

ode = sym.Eq(a0*y + a1*sym.Derivative(y,t) + a2*sym.Derivative(y,t,2), x)
sym.solve(ode.doit(),l)

"""# **SISTEMAS LINEALES E INVARIANTES EN EL TIEMPO (SLIT)**

"""

t, m, c, k = sym.symbols('t m c k', real=True)
mck = {m: 0.1, c: sym.Rational('.1'), k: sym.Rational('2.5')}
x = sym.Function('x')(t)
y = sym.Function('y')(t)

ode = sym.Eq(m*y.diff(t, 2) + c*y.diff(t) + k*y, x)
solution_h = sym.dsolve(ode.subs(x, sym.DiracDelta(t)).subs(y, sym.Function('h')(t)))
integration_constants = sym.solve( (solution_h.rhs.limit(t, 0, '-'), solution_h.rhs.diff(t).limit(t, 0, '-')), ['C1', 'C2'] )
s = sym.symbols('s')
H = sym.Function('H')(s)
H, = sym.solve(ode.subs(x, sym.exp(s*t)).subs(y, H*sym.exp(s*t)).doit(), H)
w = sym.symbols('omega', real=True)
Hjw = H.subs(s, sym.I * w)
Hjw

def aislamiento(m1,r,w1,w2):
 F0 = m1*r*w2**2
 Hjw1 = Hjw.subs(mck)
 y = F0*sym.im(sym.exp(sym.I*w*t)*Hjw1)
 sym.plot(y.subs(w,w1), (t, -15, 15), ylabel=r'$X$', xlabel=r'T');
interact(aislamiento, w1=(0,10,1), m1=(0,5,1),r=(0,5,1),w2=(0,10,1))

m1, r,w2= sym.symbols('m1 r w2', real=True)
F0 = m1*r*w2**2
a = abs(F0*(Hjw))
extrema = sym.solve(sym.Eq(sym.diff(a, w),0),w)
w0 = extrema[1:3]
w0

def aislamiento(m1,r,w1,w2):
 F0 = m1*r*w2**2
 Hjw1 = Hjw.subs(mck)
 y = F0*sym.im(sym.exp(sym.I*w*t)*Hjw1)
 sym.plot(y.subs(w,w1), (t, -15, 15), ylabel=r'$X$', xlabel=r'T');
 print("Los valores para donde el desplazamiento es máximo son:")
 return ([(w00.subs(mck)).evalf() for w00 in w0])

interact(aislamiento, w1=(0,10,1), m1=(0,5,1),r=(0,5,1),w2=(0,10,1))

def aislamiento(m1,r,w1,w2):
 F0 = m1*r*w2**2
 Hjw1 = Hjw.subs(mck)
 y = F0*sym.im(sym.exp(sym.I*w*t)*Hjw1)
 a = [(w00.subs(mck)).evalf() for w00 in w0]
 sym.plot(sym.arg(F0/y.subs(w,w1)), (t, -15, 15), ylabel=r'$X$', xlabel=r'T');
 print("El valor máximo de la amplitud sera en w1=" + str(a[1]))
interact(aislamiento, w1=(0.1,10,1), m1=(0,5,1),r=(0,5,1),w2=(0,10,1),label=r'$\varphi(j \omega)$', xlabel=r'$\omega$')

"""# **PENDULO ELASTICO**"""

from __future__ import print_function
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets

def pendulo(c_entrada):
 t, m, c, k = sym.symbols('t m c k', real=True)
 x = sym.Function('x')(t)
 y = sym.Function('y')(t)

 ode = sym.Eq(m*y.diff(t, 2) + c*y.diff(t) + k*y, x)
 mck = {m: 0.1, c: c_entrada, k: sym.Rational('2.5')}
 solution_h = sym.dsolve(ode.subs(x, sym.DiracDelta(t)).subs(y, sym.Function('h')(t)))
 integration_constants = sym.solve( (solution_h.rhs.limit(t, 0, '-'), solution_h.rhs.diff(t).limit(t, 0, '-')), ['C1', 'C2'] )
 s = sym.symbols('s')
 H = sym.Function('H')(s)
 H, = sym.solve(ode.subs(x, sym.exp(s*t)).subs(y, H*sym.exp(s*t)).doit(), H)
 w = sym.symbols('omega', real=True)
 Hjw = H.subs(s, sym.I * w)
 sym.plot(abs(Hjw.subs(mck)), (w, -15, 15), ylabel=r'$|H(j \omega)|$', xlabel=r'$\omega$');
 phi = sym.arg(Hjw)
 sym.plot(phi.subs(mck), (w, -15, 15), ylabel=r'$\varphi(j \omega)$', xlabel=r'$\omega$');


interact(pendulo, c_entrada=(0.1,1,0.1))

"""# **3.Transformada de Laplace**

**3.4  Compruebe los resultados en simulacion sobre Python
(utililzando sympy) y grafique la senal de salida para cada
caso.**
"""

## Entrada impulso para serie

s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Yext = 1/(L*C*s**2 + R*C*s + 1) * X
    yext = sym.inverse_laplace_transform(Yext.subs(RLC).subs(X, 1), s, t)
    Yint = -(R*C + L*C*s) / (L*C*s**2 + R*C*s + 1)
    yint = sym.inverse_laplace_transform(Yint.subs(RLC), s, t)
    y = yext + yint
    p1 = sym.plot(yext, (t, 0, 5), line_color='b', xlabel='$t$', ylabel='$y(t)$', show=False)
    p2 = sym.plot(yint, (t, 0, 5), line_color='g', show=False)
    p3 = sym.plot(y, (t, 0, 5), line_color='r', show=False)
    p1.extend(p2)
    p1.extend(p3)
    p1.show()
    print("Resultado transformada inversa")
    return sym.simplify(y)


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

# Entrada escalón para serie
s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Yext = 1/(L*C*s**2 + R*C*s + 1) * X
    yext = sym.inverse_laplace_transform(Yext.subs(RLC).subs(X, 1/s), s, t)
    Yint = -(R*C + L*C*s) / (L*C*s**2 + R*C*s + 1)
    yint = sym.inverse_laplace_transform(Yint.subs(RLC), s, t)
    y = yext + yint
    p1 = sym.plot(yext, (t, 0, 5), line_color='b', xlabel='$t$', ylabel='$y(t)$', show=False)
    p2 = sym.plot(yint, (t, 0, 5), line_color='g', show=False)
    p3 = sym.plot(y, (t, 0, 5), line_color='r', show=False)
    p1.extend(p2)
    p1.extend(p3)
    p1.show()
    print("Resultado transformada inversa")
    return sym.simplify(y)


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

# Simulación rampa para serie
s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Yext = 1/(L*C*s**2 + R*C*s + 1) * X
    yext = sym.inverse_laplace_transform(Yext.subs(RLC).subs(X, 1/s**2), s, t)
    Yint = - (R*C + L*C*s) / (L*C*s**2 + R*C*s + 1)
    yint = sym.inverse_laplace_transform(Yint.subs(RLC), s, t)
    return yext


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

# Entrada impulso en paralelo
s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Y = 1/(L*C*s**2 + (L/R)*s + 1) * X
    y = sym.inverse_laplace_transform(Y.subs(RLC).subs(X, 1), s, t)
    p1 = sym.plot(y, (t, 0, 5), line_color='b', xlabel='$t$', ylabel='$y(t)$', show=False)
    p2 = sym.plot(y, (t, 0, 5), line_color='r', show=False)
    p1.extend(p2)
    p1.show()
    print("y la transformada inversa nos daria como resultado")
    return sym.simplify(y)


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

# Escalón en paralelo
s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Y = 1/(L*C*s**2 + (L/R)*s + 1) * X
    y = sym.inverse_laplace_transform(Y.subs(RLC).subs(X, 1/s), s, t)
    p1 = sym.plot(y, (t, 0, 5), line_color='b', xlabel='$t$', ylabel='$y(t)$', show=False)
    p2 = sym.plot(y, (t, 0, 5), line_color='r', show=False)
    p1.extend(p2)
    p1.show()
    print("y la transformada inversa nos daria como resultado")
    return sym.simplify(y)


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

# Función rampa en paralelo
s = sym.symbols('s', complex=True)
t, R, L, C = sym.symbols('t R L C', positive=True)
X = sym.Function('X')(s)
def rnatural(r,l,c):
    RLC = { R: r, L: sym.Rational(l), C: sym.Rational(c)}
    Y = 1/(L*C*s**2 + (L/R)*s + 1) * X
    y = sym.inverse_laplace_transform(Y.subs(RLC).subs(X, 1/(s**2)), s, t)
    return y


interact(rnatural,r=(1,10,1),l=(0.1,1,0.1),c=(0.1,1,0.1))

"""# 3.5 Genere simulaciones para ejemplificar cada uno de los casos con los sistemas R,L,C serie y paralelo estudiados.
Nota: asuma condiciones iniciales cero.

**Para un sistema RLC en serie, podemos seguir la siguiente ecuación de transferencia y con ella tener los parámetros $\omega n$, $\omega d$ y $\zeta$ con los cuales se van a obtener.**


$H(s) = \frac{1}{LCs^2 + RCs + 1}  ;$

$\zeta = \frac{R}{2}\sqrt{\frac{C}{L}} ;$

$\omega n = \sqrt{\frac{1}{LC}};$

**Y**

$\omega d = \sqrt{\frac{1}{LC}\frac{1-R^2C}{4L}}$
"""

from ipywidgets import interact, interactive, fixed, interact_manual
import sympy as sym
import ipywidgets as widgets

def rnatural(R,L,C,K):
    a,w, t=sym.symbols('a,w, t', real=True)
    i=sym.Function('i')(t)
    ode=sym.Eq(i.diff(t,2)+(R/L)*i.diff(t)+(1/L*C)*i,K)
    a=R/(2*L)
    w=(1/sym.sqrt(L*C)).evalf()
    soeq= sym.dsolve(ode)
    ic=sym.solve((soeq.rhs.limit(t,0,'-'), soeq.rhs.diff(t).limit(t,0,'-')),['C1','C2'])
    it = soeq.subs(ic)
    if a > w:
        print("Sistema sobreamortiguado")
    if a == w:
        print("Sistema criticamente amortiguado")
    if a < w :
        print("Sistema subamortiguado")
    sym.plot((it.rhs), (t,0,10), ylabel=r'$I(t)$')
    return it
interact(rnatural,R=(0,10,1),L=(0,10,1),C=(0,10,1),K=(0,10,1))

"""# **4.4- ECUALIZADOR**

Implemente en python un ecualizador de audio para archivos mp3 utilizando filtros IIR. El usuario podra ingresar la url del archivo y escoger las bandas y ganancias de ecualizacion, visualizar el espectro del audio original y filtrado, y descargar los audios en mp3.


Solución:
"""

! pip install youtube-dl  &> /dev/null
!pip install soundfile  &> /dev/null
from scipy.signal import lfilter
from scipy.signal import ellip
from scipy import fft, arange
from IPython.display import Audio
import soundfile as sf
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
import os

def espectro(x, sf):

    x = x - np.average(x)

    n = len(x)
    print(n)
    k = arange(n)
    tarr = n / float(sf)
    frqarr = k / float(tarr)  # Rango de frecuencia

    frqarr = frqarr[range(n // 2)]  # n lado del rango de frecuencia

    x = fft(x) / n  # Se hace la transformada y se normaliza
    x = x[range(n // 2)]

    return frqarr, abs(x)

def filtro(Link,Frecuencia_Critica,Atenuacion,Tipo_Filtro):
 link=Link
 ! youtube-dl --extract-audio -o "audio2.%(mp3)s" --audio-format mp3  {link}  &> /dev/null

 !ffmpeg -i audio2.mp3 -y output2.wav  &> /dev/null
 nombre_out = "output2.wav"
 x, fs = sf.read(nombre_out)
 x2 = x.copy()
 ti = 63
 tf = ti + 15
 xs = x2[int(ti*fs):int((tf*fs)),:]
 K= int(len(xs)/2) + 1
 print("Segmento del audio original:")
 display(Audio([xs[:,1], xs[:,0]],rate=fs)) #Segmento de audio
 filtro = Tipo_Filtro
 N = 6
 frec = Frecuencia_Critica

 ripple_pass = 2
 ripple_stop = Atenuacion
 num, den = ellip(N, rp=ripple_pass, rs=ripple_stop, Wn=frec, btype=filtro, fs=fs)
 xf = lfilter(num, den, xs, axis=0)


 y = x[:, 0]
 y2 = xf[:, 0]
 frq, X = espectro(y, fs)
 frq2, X2 = espectro(y2, fs)
 plt.title("Espectro")
 plt.plot(frq, X, 'orange')
 plt.plot(frq2, X2, 'blue')
 plt.xlabel('Freq (Hz)')
 plt.ylabel('|X(freq)|')
 plt.tight_layout()

 plt.show()
 print("Segmento del audio ya filtrado:")
 display(Audio([xf[:,1], xf[:,0]],rate=fs)) #Resultado
 sf.write('sonido_filtrado.wav', xf, fs)
 !ffmpeg -i sonido_filtrado.wav -y sonido_filtrado.mp3  &> /dev/null
 print("El audio filtrado está listo para descargar en MP3: sonido_filtrado.mp3")

programa = interactive(filtro,{'manual': True},Link="https://www.youtube.com/watch?v=NQNzAkBF4uw",Frecuencia_Critica=(0,10000,100),Atenuacion=widgets.IntSlider(min=0, max=101, step=1, value=101),Tipo_Filtro=["highpass","lowpass"])
programa