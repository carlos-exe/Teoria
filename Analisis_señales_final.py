# -*- coding: utf-8 -*-
"""Taller_3___MOU [expo].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JXMlUJcLIIjBliIMvtlW4Ktr4hBB2kIu

# Teoría de señales - Taller 3



_Transformada de Fourier, Sistemas lineales y Modulación_

_Detección de símbolos y calculo de error_


_Presentado por:_ Miguel Muñoz,
                Carlos Ordoñez y
                Andrea Urquiza

----

# Se definen las funciones utilizadas:
"""

from matplotlib import pyplot as plt
import numpy as np
import scipy
import seaborn as sns
from scipy.fftpack import fft, fftfreq, fftshift
from scipy.signal import lti
from scipy.signal import hilbert
from scipy.integrate import cumtrapz

def amplitude_discretization(y, bit=2):
    """
    Discretiza una señal en amplitud según un número determinado de bits.

    y: señal
    bit: número de bits para usar en la discretización

    """
    # El nuevo «alfabeto» de la señal, una lista definida de valores que la señal puede tomar en amplitud
    # la creo rellenando el rango mínimo y máximo con un número finito valores equidistantes
    new_domain = np.linspace(y.min(), y.max(), 2**bit)
    #                                            ^
    # Estoy usando potencias de dos simplemente porque hay unos tipos de modulaciones digitales
    # en los que se facilita el trabajar con estos tamaños, y porque estamos familiarizados con
    # los conversores análogo-digitales de N-bit

    # Aproximo los valores continuos a los mas cercanos de mi nuevo alfabeto.
    y_n = [new_domain[np.abs(new_domain - v).argmin()] for v in y]

    return np.array(y_n)  # retorna la señal discretizada

def pulse(t, width=0.5):
    """
    A partir de un vector de tiempo retorna un pulso centralizado con un ancho proporcional al soporte de tiempo.

    t: vector de tiempo
    width: ancho del pulso
    """
    width /= 2

    return t, np.array(np.array((t.mean()-(t.max()*width)) < t, dtype=np.int)) * np.array(t <(t.max()*width+t.mean()), dtype=np.int)

def pulse_train(t, pulses=10):
    """
    Define un tren de pulsos.

    t: vector de tiempo
    pulses: número de pulsos

    """
    width = (t.max()-t.min())/(pulses)

    return t, np.array(t%width*2<(width), dtype=np.int)

def lti_simulation(lti, t, x):
    """
    lti: lti system, lo que retorna scipy
    t: vector de tiempo
    x: señal de entrada

    """
    t_, output_, _ = lti.output(x, t)

    return t_, output_  # retorna el mismo vector de tiempo y y la señal resultante

def normalization(signal):
    """
    Normaliza la señal, dejándola únicamente positiva y variando de 0 a 1

    signal: señal
    """
    signal_ = signal.copy()
    signal_ -= signal_.min()  # Se desplaza para que únicamente sea positiva
    signal_ /= signal_.max()  # Se divide por el máximo, para que el dominio sea de 0 a 1

    return signal_

def plott(t, y,y2,xlim0,xlim1,title1,title2):

  plt.figure(figsize=(16, 5), dpi=90)
  plt.subplot(121)
  plt.plot(t, y, color='C1', label='Entrada')
  plt.plot(t, y2, color='C2', label='Salida')
  plt.xlim(xlim0,xlim1)
  plt.legend()
  plt.grid(True)
  plt.title(title1)
  plt.xlabel('Time [s]')
  plt.ylabel('Amplitude')
  plt.subplot(122)
  plt.plot(t, y2, color='C2', label='Salida')
  plt.xlim(xlim0,xlim1)
  plt.legend()
  plt.title(title2)
  plt.xlabel('Time [s]')
  plt.ylabel('Amplitude')
  plt.grid(True)

## detección de cuales son los 2 simbolos y el umbral
def detec1(M,out_dem,symbols,message_):  #numero de muestras, señal salida demodulador,
  MM = int(M/2)

  plt.figure(figsize=(14, 5), dpi=90)
  A, X1, *_ = plt.hist(out_dem,M)

  mitad1 = np.zeros(MM)
  mitad2 = np.ones(MM)
  simbol1 = np.concatenate((mitad1,mitad2))
  simbol2 = np.concatenate((mitad2,mitad1))
  simbol1 = simbol1*A
  simbol2 = simbol2*A
  moda1 = max(simbol1)
  moda2 = max(simbol2)

  for i in range(MM):
    if simbol1[int(i+MM)]==moda1:
      simbolo1 = X1[int(i+MM)]
    if simbol2[i]==moda2:
      simbolo2 = X1[i]
  valormedio = ((simbolo1 - simbolo2)/2)+simbolo2  ## solo para simbolos mayores a cero
  plt.tight_layout()
  plt.axvline(x=simbolo1,ymin=0,color ='r')
  plt.axvline(x=simbolo2,ymin=0,color ='r')
  plt.axvline(x=valormedio,ymin=0,color ='r')
  plt.grid(True)

  señal = np.zeros(symbols)

  for i in range(symbols):
    señal[i] = simbolo2*(out_dem[i]<valormedio)+simbolo1*(out_dem[i]>valormedio)

  detsec = señal-min(señal)
  message_ = message_-min(message_)
  resultante = np.zeros(len(message_))

  for i in range (len(message_)):
    if detsec[i] != 0:
      detsec[i] =1

  detsec = detsec*max(message_)


  plt.figure(figsize=(17, 5), dpi=90)
  plt.subplot(121)
  plt.plot(tv,out_dem, 'r', label='salida del demodulador')
  plt.plot(tv,señal, 'b', label='salida del detector')
  plt.legend()

  plt.grid(True)
  plt.subplot(122)
  plt.plot(tv,detsec, 'b', label='salida del detector')
  plt.plot(tv,message_,'r',  alpha = 0.7, label='salida del SLIT discretizada')
  plt.legend()
  plt.grid(True)

  return detsec

"""# _1. Generación de secuencia y de ruido:_

## a. Generación de secuencia:
"""

import numpy as np
u1 = 1
u2 = -1

symbols = int(2**12)
nsy = 32

sec = np.random.choice([u1, u2], size=nsy, p=[0.5, 0.5])
sec = sec.astype('float')
#plt.step(range(nsy), sec, '-')
duracion = int(symbols/nsy)
sec = np.concatenate([[v]*duracion for v in sec])
sec.shape
plt.plot(sec)

"""## b.  Generar ruido blanco gaussiano aditivo(AWGN)


- Como la potencia del AWGN esta dada por $N_{in} = \sigma^2$ entonces este se genera con base en el parámetro varianza.


"""

# Se determina la varianza del ruido, es decir la potencia del AWGN   ||||| REVISAR COMO SE VA A AGREGAR A CADA SEC MODULADA

noisemean1 = 0
noisevar1 = 0.01
noise1 = np.random.normal(noisemean1, np.sqrt(noisevar1), len(sec))

noisemean2 = 0
noisevar2 = 0.01
noise2 = np.random.normal(noisemean2, np.sqrt(noisevar2), len(sec))

"""# _2. LTI y su función de transferencia_

---

##a. Hallar la ecuación diferencial y la función de transferencia $h(t)$.que describe el circuito 6



Para hallar la función de transferencia se hace una conversión de los elementos del circuito al dominio de la frecuencia y acto seguido se hace el equivalente de las impedancias para relacionar la tensión de entrada con la de salida.


![Circuito6.png](data:image/png;base64,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)

$$
C_1 ----> \frac{1}{S*C_1}  [Ω]
$$
$$
R1, R2 -----> R1, R2  [Ω]
$$

se soluciona el paralelo entre el capacitor y R_1


$$ R_1 || \frac{1}{SC_1}  =  \frac{R_1*\frac{1}{SC_1}}{R_1+\frac{1}{SC_1}} = \frac{R_1}{R_1*S*C_1+1}  $$

Y se obtiene que:

$$  \frac{R_1}{S*R_1*C_1+1}*X(S) = (\frac{R_1}{S*R_1*C_1+1}+R_2)*Y(S)  $$


Para hallar su función de transferencia así:

$$  \frac{Y(S)}{X(S)} = \frac{\frac{R_1}{R_1SC_1+1}}{\frac{R_1}{S*R_1*C_1+1}+R_2}  $$

$$G(s)=\frac{1}{R_2 SC+\frac{R_2}{R_1}+1} =\frac{\frac{1}{R_2 C}}{S+\frac{R_2}{R_1 R_2 C}+\frac{1}{R_2}} = \frac{1}{R_2 C} \frac{1}{S+\frac{R_1 + R_2}{C R_1 R_2}}$$


Ahora definimos la función de transferencia en el tiempo:
$$\mathcal{L^{-1}} {H(s)} =\frac{1}{R_2C}e^{\frac{R_2+R_1}{R_1R_2C}t}$$
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from matplotlib import pyplot as plt
from scipy.signal import lti
from scipy.fftpack import fft, fftfreq, fftshift

"""A continuación se verifica el cálculo de la función de transferencia por medio de código utilizando la librería sympy."""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import sympy as sym
sym.init_printing()

s = sym.symbols('s', complex=True)
t, R1, R2, C = sym.symbols('t R1 R2 C', positive=True)
X = sym.Function('X')(s)

Y = (1/(R2*C))/(s + ((R2+R1)/(R1*R2*C))) * X

y = sym.inverse_laplace_transform(Y.subs(X, 1), s, t)   #VERIFICACIÓN CON CÓDIGO
Y,y

"""Utilizando la función lti se obtiene la respuesta a impulso del sistema, caracterizado por la función de transferencia:"""

R1 = 1
R2 = 2
C = 0.4
A = 1/(R2*C)
num = [A]
den = [1,((R2+R1)/(R1*R2*C)) ]
T = np.linspace(0,symbols,symbols)
lti_system = lti(num, den)
tv, h = lti_system.impulse(N=symbols)  #se genera la respuesta impulso del sistema
plt.plot(tv, h, label='$h(t)$') #se gráfica la respuesta impulso

plt.grid(True)
plt.legend()
plt.title("Impulse response")
plt.xlabel("Time [$s$]")
plt.ylabel("Amplitude")
plt.show()
len(tv),tv[0]

"""**Observación:** se evidencia que el circuito analizado es un filtro pasa bajas con frecuencia de corte $f_c = \frac{1}{2\pi R_2C}$ por lo que va a atenuar las frecuencias mayores a este umbral.

##b. Secuencia como entrada al SLIT: Si se asume que la entrada esta dada por $x(t)$, para hallar la salida en tiempo $y(t)$ y en frecuencia ($Y(\omega)$), se efectúa el siguiente proceso:

Para este punto se tuvo en cuenta que en el tiempo la salida se da de la siguiente manera:
$$y(t)=x(t)*h(t)$$
Mientras que en frencuencia
$$Y(\omega)=X(\omega)H(w)$$

- Se halla la respuesta del sistema ante la secuencia y se comprueba que el resultado de la convolución de la secuencia y el impulso es igual al respuesta obtenida al introducir la secuencia en el sistema.
tal que la salida en tiempo y(t) y en frecuencía Y(w) quedaria de la forma:
- Notar que en frecuencia se gráfica la magnitud de la densidad espectral de energía con el fin de visualizar mejor las propiedades de la señal en frecuencia.

- **Observación: si hablamos de que se pasa la secuencia por un SLIT es porque esta implicado el tiempo, por lo tanto es un proceso**
"""

plt.figure(figsize=(10, 5), dpi=90)

out_sec = np.convolve(sec, h)[:tv.shape[0]]*((tv[-1]/tv.shape[0]))

message_ = amplitude_discretization(out_sec, 1)

plt.figure(figsize=(16, 5), dpi=90)
plt.step(tv, sec, '-', C='C0', label='Input')
plt.plot(tv, out_sec, C='r', label='Output (convolve)')
plt.plot(tv,message_, label='Output discretizada')
plt.ylabel('Respuesta del sistema')
plt.xlabel('Time[s]')
plt.legend()
plt.xlim(0,2)
plt.grid(True)

plt.figure(figsize=(16, 5), dpi=90)
plt.subplot(121)
plt.plot(tv,message_, label='Output discretizada')
plt.ylabel('Respuesta del sistema')
plt.xlabel('Time[s]')
plt.legend()
plt.xlim(0,2)
plt.grid(True)

plt.subplot(122)
plt.plot(tv, out_sec, C='r', label='Output (convolve)')
plt.ylabel('Respuesta del sistema')
plt.xlabel('Time[s]')
plt.legend()
plt.xlim(0,2)
plt.grid(True)
plt.show()

"""**Obsrvación:** Se puede concluir que las propiedades de un SLTI están completamente caracterizadas por su respuesta al impulso. La respuesta $y(t)$ de un sistema a una señal de entrada arbitraria $x(t)$ está dada por la convolución de la señal de entrada $x(t)$ con su respuesta de impulso $h(t)$.

# _3. Modulación digital de radiofrecuencia:_

##**a. ASK** (Amplitude-shift keying): Consiste en el desplazamiento de amplitud de la señal (como su nombre lo indica) y representa sus datos digitales como variaciones de amplitud de la señal portadora, de la siguiente forma:

$y(t) = \psi (t-kTs)\cos(\omega_ct$)

Donde:

$\psi(t) = rect_T (t) =$

$1; 0 <= t < T;$

$0; t<0,t>T$
"""

u = 1

# Como en AM
fc = nsy/2  # frecuencia fundamental de la portadora
carrier = np.cos(2*np.pi*fc*tv)
sim1 = max(message_)
sim2 = min(message_)
# Como en AM
ask = np.zeros(len(message_))
for i in range(len(ask)):
  if message_[i] == sim1:
    ask[i] = carrier[i]
  elif message_[i] == sim2:
    ask[i] = 0

plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv,ask, 'r')
plt.xlim(0,2)
# plott(tv,out_sec,ask, 0, 2, 'salida vs salida modulada por ask', 'ask')
#plott(tv,message_,ask, 0, 10)

"""### - Se agrega ruido a secuencia modulada ASK."""

ask_n = np.zeros(len(ask))
for i in range (len(ask)):
  if ask[i] != u2:
    ask_n[i] = ask[i] + noise1[i]
  elif ask[i] == u2:
    ask_n[i] = ask[i] + noise2[i]
# plott(tv,ask,ask_n,0,2,'ask vs ask con ruido', 'ask con ruido')
plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv,ask)
plt.plot(tv,ask_n)

"""### - Demodulación ASK."""

analytic_signal = hilbert(ask_n)
amplitude_envelope = np.abs(analytic_signal)
d_am =amplitude_envelope /max(amplitude_envelope)

d_am = d_am-min(d_am)

plt.figure(figsize=(16, 5), dpi=90)
plt.subplot(121)
plt.plot(tv, ask_n, label='Señal ask con ruido')
plt.plot(tv, amplitude_envelope, label='envelope')
plt.grid(True)
plt.legend()
plt.xlim(0,2)
plt.subplot(122)
plt.plot(tv, d_am, label='Señal demodulada')
plt.grid(True)
plt.legend()
plt.xlim(0,2)
plt.show()

"""### - **Comparación Señal demodulada - Salida SLIT**"""

import numpy as np
from scipy.signal import butter, lfilter, freqz , filtfilt
import matplotlib.pyplot as plt

order = 5
Wn = 0.38   # 0< wn<1
b, a = butter(order, Wn, btype='low', analog=False, fs = 50)    #https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html

y = filtfilt(b, a, d_am)
plt.figure(figsize=(16, 5), dpi=90)
plt.plot(tv, y, 'g-', linewidth=2, label='salida del demodulador')
plt.plot(tv,message_-min(message_), label='salida del SLIT (discretizada)')
plt.xlabel('Time [sec]')
plt.grid()
plt.legend()
plt.show()

"""###  - Detección ASK."""

detask = detec1(500,y,symbols,message_)

"""## b. Modulación FSK

El FSK binario es una Forma de modulación angular de amplitud constante, similar a la modulación en frecuencia convencional, excepto que la señal moduladora es un tren de pulsos binarios que varía, entre dos niveles de voltaje discreto, en lugar de una forma de onda analógica que cambia de manera continua. La expresión general para una señal FSK binaria es:

$$V_{FSK} = Acos(w_{c}t+2\pi\Delta f t)$$

donde $\Delta f =$  desviación de fase

Así conforme cambia la señal de entrada binaria de 0 lógico a 1 lógico, y viceversa, la salida del FSK se desplaza entre dos frecuencias: *una frecuencia de marca o de 1 lógico* y una *frecuencia de espacio o de 0 lógico*. Con el FSK binario, hay un cambio en la frecuencia de salida, cada vez que la condición lógica de la señal de entrada binaria cambia.
![FSK.gif](data:image/gif;base64,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)

"""

f = fc
# f = 20
df = f/2
sim1 = max(sec)
sim2 = min(sec)
# Se determina que frecuencia codifica cada simbolo
fsk = np.zeros(len(sec))
for i in range(len(fsk)):
  if sec[i] == sim1:
    f1 = f+df
    fsk[i] = np.cos(2*np.pi*f1*tv[i])
  elif sec[i] == sim2:
    f2 = f-df
    fsk[i] = np.cos(2*np.pi*f2*tv[i])
plott(tv, sec, fsk, 0, 1.75,'Salida al SLIT vs Modulada','Salida al SLIT Modulada')

beta = 15
fsk1 = np.cos((2*np.pi*fc*tv) + beta*2*np.pi*cumtrapz(sec, tv, initial=0))

"""### Se agrega ruido a secuencia modulada FSK."""

fsk_n = np.zeros(len(fsk1))
for i in range (len(fsk1)):
  if message_[i] != 0:
    fsk_n[i] = fsk1[i] + noise1[i]
  elif message_[i] == 0:
    fsk_n[i] = fsk1[i] + noise2[i]

plt.figure(figsize=(16, 5), dpi=90)
plt.subplot(121)
plt.plot(tv,fsk1, color = 'g')
plt.title('Secuencia modulada FSK')
plt.grid(True)
plt.subplot(122)
plt.plot(tv,fsk_n, color = 'C1')
plt.title('Secuencia modulada FSK con ruido')
plt.grid(True)

"""### Demodulación FSK.

Debido a que sólo hay dos frecuencias de entrada (marea y espacio), también hay sólo dos voltajes de salida. Uno representa un 1 lógico y el otro un 0 lógico. En consecuencia, la salida es una representación de dos niveles (binaria) de la entrada de FSK. Por lo regular, la frecuencia natural de la salida se hace igual a la frecuencia central del modulador de FSK. Como resultado, los cambios en el voltaje, siguen a los cambios en la frecuencia de entrada analógica y son simétricos alrededor de 0 V.
"""

dev = np.diff(fsk1)/np.diff(tv)
dev_ = np.append(dev,min(dev))
## Se demodula aplicando método de AM
z_fsk = np.sin(2*np.pi*20*tv)*dev_

### DETECTOR DE ENVOLVENTE
analytic_z= hilbert(dev_)                                    #https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert.html
envelope_z = np.abs(analytic_z)
zz_fsk = envelope_z/max(envelope_z)


# Se lleva a cero
zz_fsk = zz_fsk-min(zz_fsk)

# Se filtra la envolvente detectada
order = 5
Wn = 0.18   # 0< wn<1
b, a = butter(order, Wn, btype='low', analog=False, fs = 25)
d_fsk1 = filtfilt(b, a, zz_fsk)


plt.figure(figsize=(16, 5), dpi=90)
plt.subplot(131)
plt.plot(tv, dev_, label='Señal convertida en AM')
plt.plot(tv, envelope_z, label='Envolvente detectada')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.subplot(132)
plt.plot(tv, zz_fsk, label='Señal escalada')
plt.xlabel('Time [s]')
plt.grid(True)
plt.legend()
plt.subplot(133)
plt.plot(tv, d_fsk1*10-min(d_fsk1*10), label='Señal demodulada FSK')
plt.plot(tv, message_-min(message_), label='Secuencia moduladora')
plt.xlabel('Time [s]')
plt.ylim(-1,2.5)
plt.grid(True)
plt.legend()
plt.show()

## Se pasan las variaciones de frecuencia a variaciones de amplitud
dev = np.diff(fsk_n)/np.diff(tv)
# --- se filtra para poder detectar la envolvente ---
order = 5
Wn = 0.18   # 0< wn<1
b, a = butter(order, Wn, btype='low', analog=False, fs = 2)
dev_ = filtfilt(b, a, dev)
dev_ = np.append(dev_,min(dev_))

plt.figure(figsize=(16, 5), dpi=90)
plt.plot(tv, dev_, label='signal')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.grid(True)

## Se demodula aplicando método de AM
z_fsk = np.sin(2*np.pi*20*tv)*dev_

### DETECTOR DE ENVOLVENTE
analytic_z= hilbert(dev_)                                    #https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert.html
envelope_z = np.abs(analytic_z)
zz_fsk = envelope_z/max(envelope_z)


# Se lleva a cero
zz_fsk = zz_fsk-min(zz_fsk)

# Se filtra la envolvente detectada
order = 5
Wn = 0.18   # 0< wn<1
b, a = butter(order, Wn, btype='low', analog=False, fs = 25)
d_fsk = filtfilt(b, a, zz_fsk)

d_fskk = d_fsk*10-min(d_fsk*10)

plt.figure(figsize=(16, 5), dpi=90)
plt.subplot(131)
plt.plot(tv, dev_, label='Señal convertida en AM')
plt.plot(tv, envelope_z, label='Envolvente detectada')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.subplot(132)
plt.plot(tv, zz_fsk, label='Señal escalada')
plt.xlabel('Time [s]')
plt.grid(True)
plt.legend()
plt.subplot(133)
plt.plot(tv, d_fsk, label='Señal demodulada FSK')
plt.plot(tv, message_-min(message_), label='Secuencia moduladora')
plt.xlabel('Time [s]')
plt.ylim(-1,2.5)
plt.grid(True)
plt.legend()
plt.show()

algo1 = np.zeros(100)
algo2 = np.ones(4096-100)
algo = np.concatenate((algo1,algo2))
señal= algo*(d_fsk-0.08)
plt.plot(tv,señal)

"""### Detección FSK."""

detfsk = detec1(500,d_fsk,symbols,message_)

"""## c. Modulación PSK

La modulación por desplazamiento de fase o PSK (Phase Shift Keying) es una forma de modulación angular que consiste en hacer variar la fase de la portadora entre un número determinado de valores discretos. La diferencia con la modulación de fase convencional (PM) es que mientras en esta la variación de fase es continua, en función de la señal moduladora, en la PSK la señal moduladora es una señal digital y, por tanto, con un número de estados limitado.
"""

## PSK de miguel
## como defino la frecuencia parce, pues sencillo, yo quiero 3 periodos por intervalo de tiempo, que yo se que es symbols/nsy = 128
fc =(nsy/2)
carrier = np.sin(2*np.pi*fc*tv)  #tiene symbols datos
sim1 = max(message_)
sim2 = min(message_)
amp = 1
psk = np.zeros(symbols)
pskn1 = np.zeros(symbols)
pskn2 = np.zeros(symbols)
pskn3 = np.zeros(symbols)
demo1 = np.zeros(symbols)
demo2 = np.zeros(symbols)
demo3 = np.zeros(symbols)
for i in range(symbols):
    psk[i] = amp*carrier[i]*(message_[i] == sim1)+amp*-carrier[i]*(message_[i] == sim2)

plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv, psk, label='Output (convolve)')
plt.plot(tv, message_,linewidth=7, alpha=0.3, label='entrada')

"""### Se agrega ruido a secuencia modulada PSK."""

for i in range(symbols):
  if message_[i] == sim1: #para simbolo 1 hay mas ruido
    pskn1[i] = (amp*carrier[i]+noise1[i])
  if message_[i] == sim2:  #para simbolo 0 hay menos ruido
    pskn2[i] = (amp*-carrier[i]+noise2[i])

pskn3 = pskn1 + pskn2
plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv, pskn3, label='psk con ruidos')
plt.plot(tv, message_,'--', label='entrada')
#plt.plot(tv, psk,linewidth=7, alpha=0.3, label='Output (convolve)')
plt.legend()
plt.show()
sim1, sim2

plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv, pskn3, label='Output (convolve)')
plt.plot(tv, carrier, label='Output (convolve)')

"""### Demodulación PSK."""

demo1 = psk/carrier
demo2 = pskn3/carrier
plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv, message_,linewidth=7, alpha=0.3, label='entrada')
plt.plot(tv, demo2, label='Output (convolve)')
plt.plot(tv, demo1, label='Output (convolve)')
plt.ylim(-2,2)

demo11 = demo1-0.2
demo12 = demo1+0.2
for i in range(symbols):
  if (demo2[i] < demo12[i]) & (demo2[i]>demo11[i]):
    demo3[i] = demo2[i]
  if (demo2[i] > demo12[i]) or (demo2[i]<demo11[i]):
    demo3[i] = demo1[i]


plt.figure(figsize=(20, 5), dpi=90)
plt.plot(tv, demo3, label='Output (convolve)')
plt.plot(tv, demo11, label='Output (convolve)')
plt.plot(tv, demo12, label='Output (convolve)')

"""### Detección PSK."""

detpsk = detec1(500,demo3,symbols,message_)

"""# _4. Cálculo de la probabilidad de error_

La fidelidad de la detección se identifica por medio de la probabilidad de error, así la fidelidad es mayor a medida que la probabilidad de trocamiento es menor y más grande es la distancia energética de la señales de información. Lo que es equivalente en sistemas analógicos a la relación S/N.

Así podemos determinar que la probabilidad de error esta dada por la siguiente razón:   $P_{ERROR} = \frac{N_{trocados}}{N}$
"""

def perr(sec, detsec):
  e = 0
  for i in range(len(sec)):
    if sec[i] != detsec[i]:
      e = e + 1

  return e/len(sec)

##p[i] = np.abs(sec[i] - detsec[i])*100
##p = np.zeros(len(sec))

"""**a. Error de ASK.**"""

#[perror_ask, p_ask] = perr(message_, detask)
message_ = message_ - min(message_)
perror_ask = perr(message_, detask)

perror_ask

"""**b. Error de FSK.**"""

perror_fsk = perr(message_, detfsk)

perror_fsk

"""**c. Error de PSK.**"""

perror_psk = perr(message_, detpsk)

perror_psk

"""#Referencias bibliograficas:



1.   Teoría de Señales: Fundamentos (2010). Francisco Vargas, Mauricio Álvarez, Mauricio Orozco, Germán Castellanos



"""