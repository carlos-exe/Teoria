# -*- coding: utf-8 -*-
"""Mod_y_simu_Ejercicios_Cap3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dPuKCX4FHIlNz7c343k6Uo1vVV-qE6NW

# Modelado y simulación - Ejercicios capítulo 3 (Parte computacional).
Carlos Andrés Ordóñez Cerón 1004731705

####Librerías Usadas
"""

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

"""###**Sección 3.1**

#### Ejercicio 3.1.1

\begin{equation}
\dot { x } =1+rx+x^2
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=1+r*x+x**2
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# plt.axis([-2.5, 2.5, -300, 100])
plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1=1+r*x+x**2
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')
  roots[j]

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return 1+r*x+x**2


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -5, 19]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""#### Ejercicio 3.1.4

\begin{equation}
\dot { x } =r+\frac{x}{2}-\frac{x}{x+1}
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=r+(x/2)-(x/(1+x))
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')


plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1= r+(x/2)-(x/(1+x))
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return x**2-(161)**(1/2)+10


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
plt.axis([ti, tf, -40, 40])
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -10, 20]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""###**Sección 3.2**

#### Ejercicio 3.2.1

\begin{equation}
\dot { x } =rx+x^2
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=r*x+x**2
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# plt.axis([-2.5, 2.5, -300, 100])
plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1=r*x+x**2
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return r*x+x**2


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -5, 19]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""#### Ejercicio 3.2.3

\begin{equation}
\dot { x } =x-rx(1-x)
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=x-r*x+r*x**2
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

plt.axis([-2.5, 2.5, -3, 1])
plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1=x-r*x+r*x**2
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return x-r*x+r*x**2


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -5, 7]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""###**Sección 3.4**

#### Ejercicio 3.4.1

\begin{equation}
\dot { x } =rx+4x^3
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=r*x+4*x**3
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# plt.axis([-2.5, 2.5, -300, 100])
plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1=r*x+4*x**3
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return r*x+4*x**3


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -10, 10]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""#### Ejercicio 3.4.3

\begin{equation}
\dot { x } =x+\frac{rx}{1+x^2}
\end{equation}
"""

x=np.linspace(-10,10,100)
r=-5
x_dot=x+(r*x/(1+x**2))
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.spines['left'].set_position(('data',0.0))
ax.spines['bottom'].set_position(('data',0.0))
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# plt.axis([-2.5, 2.5, -300, 100])
plt.plot(x,x_dot)
plt.grid()

x=sp.symbols('x')
x_dot1=x+(r*x/(1+x**2))
roots=sp.solve(x_dot1)
print(roots)
for j in range(len(roots)):
  plt.plot(roots[j],0,'ro')

def fun (t,x,r,b):
  #return 1+r*x+x**b
  return x+(r*x/(1+x**2))


r,b=-5,0  # El mismo r pasado y b en caso de tenerlo en la ecuación

ti=0; tf=1; dt=100
tspam=[ti, tf]
t=np.linspace(ti,tf,dt)
for x0 in np.arange(-5,7,0.5):
  sol=solve_ivp(fun,tspam,[x0],args=(r,b),t_eval=t)
  plt.plot(sol.t, sol.y[0])

plt.axis([ti, tf, -20, 20]) #Mismo límite de las condiciones iniciales
plt.grid()

ti=0; tf=100; dt=1000
tspam=[ti, tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='darkgreen', marker='.')

tspam=[ti, -tf]

for r in np.arange(-5,5,0.2):
  for x0 in np.arange(-5,5,0.7):
    sol=solve_ivp(fun,tspam,[x0],args=(r,b))
    plt.scatter(r, sol.y[0][-1], color='red', marker='.')


plt.axis([-5, 5, -10, 10])
plt.grid()

"""###**Sección 3.5**

####Ejercicio 3.5.1

No debería haber equilibrio entre $\frac{\pi}{2}$ y $\pi$, ya que la rotación forzaría la cuenta hacia abajo y afuera, además, la gravedad forzaría la cuenta hacia abajo. Entonces esto implica que las fuerzas no se cancelarían y en consecuencia, la cuenta no se movería.

####Ejercicio 3.5.3

Aplicando una expansión con series de Taylor en $f(\phi) = sin(\phi)(\gamma cos(\phi)-1)$ centrado en $\phi = 0$, da como resultado:

$$(\gamma-1)\phi+(\frac{1}{6}-\frac{2\gamma}{3})\phi^3+O(\phi^5)$$
"""